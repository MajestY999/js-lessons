//Обзор работы Js
//Особенности js 
//Он высокоуровневый со сборщиком мусора, то есть как питон, Язык GO (GC) и даем управление памятью нашему компьютеру или системе
//JIT компилируемый
//Мультипарадигмальный
//Однопоточный
//Динамически типизированный

//Низкоуровневыные языки это когда мы можем например управлять памянтью системы(C, Rust ...)


//JIT(Just in time) из текста в байт код. и содержит набор команд, но это дальше
//3 стиля кода: Продцедурный. ОБъектно-ориетнированный. Функциональный

//JS однопоточный, но для этого у нас цикл событий, который нам помогает управлять циклом событий, и помогает соеденить frontend и  backend


//Процесс исполнения Javascript

//Всего 3 движка исполнения js так сказать хромоподобных.
//8 Engine Chrome, Edge
//Spider Monkey(fireFox)
// JS core(Safari, macOS, IOS)
//Но ведут внутри они себя все по разному.


//Что Внутри

 //Call stack -- стек вызовов и контекст вызовов const a = 5


 //Heap -- большое хранилище в памяти, то есть объекты в памяти(куча)


 //Почему js JIT компилируемый. 
 //Исходный код --> Машинный код --> Исполнение


 //Как работают движки под капотом 
 //JS code --> AST(абстактное синтаксическое дерево.) --> Компиляция --> Исполнение! -->Оптимизация (и компиляция идет обратно к Компиляции)



//Web APIs / Node
//Dom, Timers, Fetch, GEO.

//Движок JS(Это стек вызовов и как в него попадает контекст )
//Call stack
//Heap


//Call Queue
//Очередь коллбэков, например сходить в бэк и взять данные 

//Но всеми этими тремя элементами управляет и обеспечивает совместную работу через eventloop



//Контекст использования и stack вызова


//Что такое контекст и когда он исполняется:
//1 содается глоб контекст
// и создаем в нем глобальный код или как бы контекст 

// Что внтури контекста: 
//Это переменные(их окружение)
//Scope chain -- ссылки на переменные вне текущего контекста 
//this

const a = 5;

function doule(a){
    return a * a
}

function logDouble(a){
    console.log(doule(a));
}
console.log(`Строгое значение ${a}`);//25 Тут вызываем глобальный контекст
logDouble(a)//25 

//Stack вызовов потому что он вызывается сам на себя

//Пример работы call stack

const sum = 1;
console.log(sum)
console.log('start');

function add5(n){
    n = n + 5;//лучше писать какие либо значения так как возможен бесконечный цикл до 11500 
    if(n > 10){
        return n;
}
 console.log(n); 
 return add5(n)      
}
add5(sum)
console.log('ended');

//Примитивы и объекты

let firstName = 'Anton';
let  firstName2 = firstName;
firstName = 'New'//здесь дынне так сказать убудт пересекаться когда м ыменяем у них значения то есть когда мы начинаем делать так что переназываем данные переменных, то есть firstName идет в 0002(New), а firtsName2 идет в 0001(Anton)
console.log(firstName);
console.log(firstName2);

const user1 ={
    name: 'Anton',//Здесь же как раз объект не может находиться в call stack из за ограничений, а все данные будут идти в кучу где непосредственно храниться сам объект 

}
const user2 = user1// Тут теперь мы делаем также только теперь мы идем к тому же объекту и меняем его имя как в идексе .name будет = name:New  в той же ячейке памяти.

user2.name = 'New'
console.log(user1);
console.log(user2);//Это из за того что тут мы работаетм с объектами и структура хранения работает у них по разному с простыми примитивными переменными
//Примитивные: Number, string, boolean, undefined, Null, Symbol, bigInt
//Обьекты(ссылочные типы): Object Literals, Arrays, Functions,  и т.д...
//Примитивные типы находятся в Call stack, а ссылочные типы в heap(куча)

// В итоге нельзя менять имя или название внутри объектов то есть например у нас есть объект и в нм некоторые переменные или элементы и хотим поменять их название но у нас не получиться это сделать так как они сложны и делатьется наверное это по другому но этого я пока что не знаю и как это делается тоже(либо это из за того что у нас только один элемент внутри объекта)


//Пример примитивов и объектов
const user = {
    name: 'Anton',
    id: 1,
    roles: ['Admin']
};
// user.name = 'New user'
// console.log(user);
//для изменения объекта нужно использовать не константу а изменяемую переменную let, которая сможет появиться в куче. Но и работает потому что мы же не меняем местами объекты или имена элементов внутри объектов

const newUser =  Object.assign({}, user);//используем Object.assign потому что мы пытаемся сделать его 'мерджим'
user.name = 'NewUser';
console.log(user);
console.log(newUser);


const newUser2 =  {
    ...user //просто копируем данные из обьекта, используем  spred оператор.
}
newUser2.name = 'NewUser';
newUser2.roles.push('User')//Данные изменятся в обоих объектах потому что используем spred оператор, и чтобы такого не было используют глубокое копирование.
console.log(user);
console.log(newUser)